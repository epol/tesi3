\documentclass[a4paper,10pt]{amsbook}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{xfrac}
\usepackage[all]{xy}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
%\usepackage{fullpage}
\usepackage{hyperref}
\usepackage[utf8x]{inputenc}
\usepackage[italian]{babel}

%\setlength{\parindent}{0in}

\newcounter{counter1}

\theoremstyle{plain}
\newtheorem{myteo}[counter1]{Teorema}
\newtheorem{mylem}[counter1]{Lemma}
\newtheorem{mypro}[counter1]{Proposizione}
\newtheorem{mycor}[counter1]{Corollario}
\newtheorem*{myteo*}{Teorema}
\newtheorem*{mylem*}{Lemma}
\newtheorem*{mypro*}{Proposizione}
\newtheorem*{mycor*}{Corollario}

\theoremstyle{definition}
\newtheorem{mydef}[counter1]{Definizione}
\newtheorem{myes}[counter1]{Esempio}
\newtheorem{myex}[counter1]{Esercizio}
\newtheorem*{mydef*}{Definizione}
\newtheorem*{myes*}{Esempio}
\newtheorem*{myex*}{Esercizio}

\theoremstyle{remark}
\newtheorem{mynot}[counter1]{Nota}
\newtheorem{myoss}[counter1]{Osservazione}
\newtheorem*{mynot*}{Nota}
\newtheorem*{myoss*}{Osservazione}


\newcommand{\obar}[1]{\overline{#1}}
\newcommand{\ubar}[1]{\underline{#1}}

\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\pa}[1]{\left(#1\right)}
\newcommand{\ang}[1]{\left<#1\right>}
\newcommand{\bra}[1]{\left[#1\right]}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\norm}[1]{\left\|#1\right\|}

\newcommand{\pfrac}[2]{\pa{\frac{#1}{#2}}}
\newcommand{\bfrac}[2]{\bra{\frac{#1}{#2}}}
\newcommand{\psfrac}[2]{\pa{\sfrac{#1}{#2}}}
\newcommand{\bsfrac}[2]{\bra{\sfrac{#1}{#2}}}

\newcommand{\der}[2]{\frac{\partial #1}{\partial #2}}
\newcommand{\pder}[2]{\pfrac{\partial #1}{\partial #2}}
\newcommand{\sder}[2]{\sfrac{\partial #1}{\partial #2}}
\newcommand{\psder}[2]{\psfrac{\partial #1}{\partial #2}}

\newcommand{\intl}{\int \limits}

\DeclareMathOperator{\de}{d}
\DeclareMathOperator{\id}{Id}
\DeclareMathOperator{\len}{len}

\DeclareMathOperator{\gl}{GL}
\DeclareMathOperator{\aff}{Aff}
\DeclareMathOperator{\isom}{Isom}

\DeclareMathOperator{\im}{Im}




\title{Tesi}
\author{Enrico Polesel}
\date{\today}

\begin{document}
\maketitle

\setcounter{tocdepth}{5}

\tableofcontents

\chapter{Camminimi minimi su grafi}

\begin{mydef}[Grafo]
  Chiamiamo grafo la coppia $G = (V,E)$ dove $V$ è un insieme finito
  di elementi detti \textit{nodi} e $E\subseteq V \times V$ di
  relazioni chiamate archi.
\end{mydef}

Se non specificato diversamente definiamo $N = \abs{V}$ e $M =
\abs{E}$.

Diciamo che gli archi di un grafo sono pesati se esiste una funzione
\textit{peso}
\[ w : E \rightarrow \mathbb{R} \]
Per noi il peso di un arco rappresenta la sua lunghezza, per questo
chiameremo con \textit{lunghezza di un arco} il suo peso.

Nel caso non pesato ci riconduciamo al caso pesato prendendo $w$
costante a $1$.

Siamo interessati a considerare grafi diretti, cioè gli archi sono
orientati, nel caso indiretto possiamo ridurci a questo caso
considerando l'insieme di archi 
\[ V' = V \cup \set{ (w,v) \mid (v,w) \in V } \]

\begin{mydef}[Cammino]
  Chiamiamo \textit{cammino} sul grafo $G$ una successione ordinata
  finita di nodi $p = ( v_0, v_1, ..., v_k)$ tale che 
  \[ \forall i \in \set{ 1, ... , k} \;\;\; (v_{i-1}, v_{i} ) \in E\]
\end{mydef}

Diciamo che $p$ congiunge $v_0$ a $v_k$. Dati due nodi $v,w$ chiamiamo
$P(v,w)$ l'insieme (eventualmente vuoto) dei cammini che congiungono
$v$ a $w$

Dati due cammini $p = ( v_0, v_1, ..., v_k)$ e $q = ( w_0, w_1, ...,
w_{h})$ tali che $v_k = w_0$ chiamiamo somma dei due cammini il
cammino
\[ p+q = ( v_0, v_1, ..., v_k= w_0, w_1, ..., w_{h}) \]

Dato un cammino $p = ( v_0, v_1, ..., v_k)$ chiamiamo
\textit{sottocammino} di $p$ un cammino $q = ( v_i , v_{i+1}, ... ,
v_j )$ con $o \le i \le j \le k$.

\begin{mydef}[Lunghezza di un cammino]
  Chiamiamo lunghezza di un cammino $p$ la quantità
  \[ w(p) = \sum _{i=1} ^k w(v_{i-1}, v_i ) \]
\end{mydef}

Osserivamo che la lunghezza della somma di due cammini è uguale alla
somma delle lunghezze.

Siamo interessati a trattare grafi in cui gli archi hanno lunghezza
non negativa, per cui da ora usiamo l'ipotesi $\forall e \in E \; w(e)
\ge 0$.

\begin{mydef}[Distanza di due punti]
  \[ \delta(v,w) = \left\{
    \begin{matrix}
      \min \limits_{p \in P(v,w)} { w(p) } & \; P(v,w) \neq \emptyset \\
      \infty & \; P(v,w) = \emptyset
    \end{matrix}
    \right.
    \]
\end{mydef}

Per $P(v,w) \neq \emptyset$ chiamiamo \textit{cammino minimo} fra $v$
e $w$ un cammino la cui lunghezza realizza il minimo.

Osserviamo che questa distanza verifica le proprietà
\begin{itemize}
\item $\delta(v,v) = 0$ infatti il cammino $(v)$ ha lunghezza $0$
\item $\delta(v,z) \le \delta(v,w) + \delta(w,z)$ infatti sommando il
  cammino minimo tra $v$ e $w$ e quello tra $w$ e $z$ si ottiene un
  cammino in $P(v,z)$
\end{itemize}
Questa distanza, però, in generale non è simmetica, quindi definisce
una pseudometrica. Nel caso di grafi non orientati allora $\delta$
diventa una distanza.

Osserviamo, infine, che ogni sottocammino di un cammino minimo è
ancora minimo.



\section{Cammini minimi da una sorgente unica}

Fissiamo un nodo $s \in V$ che chiameremo sorgente. Siamo interessati
a calcolare:
\begin{itemize}
\item le distanze $\delta(s,v)$ al variare di $v\in V$
\item i cammini minimi tra $s$ ed ogni nodo $v\in V$
\end{itemize}

Se scegliamo un cammino minimo da $s$ a $v$ per ogni $v\in V$ e
consideriamo l'insieme degl'archi che compaiono in questi archi
otteniamo un albero\footnote{TODO: In realtà i cammini vanno scelti
  bene}

Per questo per ogni nodo $v\in V$ definiamo
\begin{itemize}
\item $v.d = \delta(s,v)$
\item $v.p$ il predecessore di $v$ nel cammino minimo scelto
\end{itemize}

\subsection{Archi non pesati: BFS}

Nel caso in cui tutti gli archi hanno lunghezza $1$ l'albero dei
cammini minimi può essere costruito con una visita in ampiezza (BFS:
breadth-first search).

\begin{algorithmic}
  \For {v $\in$ V}
    \State{v.d = $\infty$}
    \State{v.p = v}
  \EndFor
  \State{s.d = 0}
  \State{q = Queue()}
  \State{q.push(s)}
  \While{ ! q.empty()}
    \State{v = q.pop()}
    \For{w $\in$ v.neigh}
      \If{w.d = $\infty$}
        \State{w.d = v.d + 1}
        \State{w.p = v}
        \State{q.push(w)}
      \EndIf
    \EndFor
  \EndWhile
\end{algorithmic}

Vogliamo dimostrare la correttezza dell'algoritmo. Per farlo definiamo,
ad ogni passaggio dell'algoritmo, l'insieme $S = \set{ v \in V \mid
  v.d \neq \infty}$. 

\begin{mylem}
  Se $v \in S$ allora $v.d = \delta(s,v)$
\end{mylem}

\subsection{Archi pesati: Dijkstra}

\section{Cammini minimi fra ogni coppia}

\subsection{Un cammino per ogni coppia}

\subsection{Tutti i cammini per ogni coppia}

\chapter{Oracoli per distanze}

\section{Oracoli approssimati}

\section{Oracoli esatti}

Tutte le distanze in $O(n^2)$ spazio con query costanti




\chapter{Problema dei $k$ cammini minimi}



\chapter{Tutti i cammini minimi}

\section{Un primo algoritmo}

$O(n^3)$

\section{Un algoritmo con tempo di query non ottimale}


\section{Una classe particolare: grafi planari}

$O(n^{2.5})$ con il separation theorem

\section{Un nuovo algoritmo}

???

\section{Il caso difficile}







\end{document}

